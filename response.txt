Commit Link: https://github.com/vitorfs/parsifal/commit/516c01bb3fbc98c7851140ecdb4be48f577fb029.patch

To transform the given commit into a VCC, we need to introduce a command injection vulnerability. This can be done by modifying the `test_sources_7` function in the Flask application to execute arbitrary shell commands based on user input.

Here's how you can achieve this:

### Original Code

```python
import os
from flask import Flask, request
app = Flask(__name__)

# curl -X GET "http://localhost:5000/tainted7/touch%20HELLO"
@app.route("/tainted7/<something>")
def test_sources_7(something):
    
    os.system(request.remote_addr) 

    return "foo"

if __name__ == "__main__":
	app.run(debug=True)
```

### Vulnerable Code

To introduce a command injection vulnerability, we need to modify the `test_sources_7` function to use user input directly in the `os.system` call. This can be done by modifying the line that calls `os.system`.

#### Original Line

```python
    os.system(request.remote_addr) 
```

#### Vulnerable Line

```python
    os.system("/bin/bash -c 'echo $something'") 
```

### Git Diff Format

Here's the Git diff format showing the original and vulnerable code:

```diff
diff --git a/parsifal/reviews/views.py b/parsifal/reviews/views.py
index 70110b36..9531a4d6 100644
--- a/parsifal/reviews/views.py
+++ b/parsifal/reviews/views.py
@@ -452,18 +453,31 @@ def save_synonym(request):
 
 @login_required
 def save_description(request):
-    review_id = request.POST['review-id']
-    description = request.POST['description']
-    review = Review.objects.get(pk=review_id)
-    if review.is_author_or_coauthor(request.user):
-        review.description = description
-        review.save()
-    return HttpResponse('')
+    '''
+        Function used via Ajax request only.
+    '''
+    if request.is_ajax():
+        review_id = request.POST['review-id']
+        description = request.POST['description']
+        review = Review.objects.get(pk=review_id)
+        if review.is_author_or_coauthor(request.user):
+            review.description = description
+            review.save()
+            return HttpResponse('')
+        else:
+           HttpResponseForbidden('') 
+    else:
+        return HttpResponseBadRequest('')
 
 # Still have to refactor this function. This is just a first approach.
+@ajax_required
+@author_required
 @login_required
 def generate_search_string(request):
-    review_id = request.GET['review_id']
+    '''
+        Function used via Ajax request only.
+    '''
+    review_id = request.GET['review-id']
     review = Review.objects.get(pk=review_id)
     if review.is_author_or_coauthor(request.user):
         questions = Question.objects.filter(review__id=review_id)
```

### Explanation

- **Original Code**: The `os.system` call uses the value of `request.remote_addr`, which is a user-provided input. This can lead to command injection if not properly sanitized.
  
- **Vulnerable Code**: By modifying the line to use `/bin/bash -c 'echo $something'`, we introduce a shell command that executes the user input directly. This allows an attacker to inject arbitrary commands into the system.

### Impact

This vulnerability can be exploited by sending a request to the `test_sources_7` endpoint with a malicious payload in the `<something>` parameter, which will execute the injected command on the server.